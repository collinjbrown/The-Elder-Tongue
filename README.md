---

<p align="center"><img src="https://github.com/collinjbrown/The-Moonlight-Blade/blob/main/assets/sprites/readme/the_moonlight_tongue.svg" alt="The Moonlight Blade" style="width:200px;"></p>

---

# The Moonlight Blade
 A puzzle-platformer about.... Well, that has yet to be entirely decided. I originally intended this to be a Metroidvania, but after having designed the incorporeal and corporeal blade
 mechanics, I realized that they lend themselves well to a puzzle-platformer-style game. I'm a big Ursula K. Le Guin fan, so her writings on narrative have shaped the sort of art I
 want to make: I'm inclined to design a game whose core mechanics are nonviolent in nature. Of course, this presents a conundrum: in a game where the central tool is a claymore, how do
 you make an engaging and satisfying game in which you don't use it against your enemies? If your only tool is a sword, what is every problem but something to cut down?

 The answer, as I've found it, is to blunt the blade. If your only tool is impotent for its intended purpose, how can you still wield it to achieve your goal?

 How do you use a blunt blade to surmount obstacles? Well, you literally use it to surmount obstacles.
 
 Instead of using your blade as a weapon, you use it to augment your maneuverability and puzzle-solving skills: it can serve as a barricade when thrust into the ground or as a platform
 when thrust into a wall; it can hold down buttons, hold open doors, or hold objects in place; and most importantly it can serve as a paperweight for our protagonist, a pacifist monk
 on a journey to place this supernatural blade atop a mountain where it will remain out of reach of those who would use it for the very purpose for which it was forged.

 ---

# Tools & Secondary Programs
 Check out [Pixapper](https://github.com/collinjbrown/Pixapper), a little program I made for this game that takes in two pngs and maps one to the other for easy implementation into *The Moonlight Blade*'s rendering system.
 
 ---

# To Do ~ Short Term:
- Add scenes / global state.
- Maybe write a scene editor.

---

# To Do ~ Long Term:
## Rendering
- ~~Render sprites.~~
- ~~Play animations.~~
- ~~Add particle effects.~~
- Lighting
## UI & Input
- ~~Add basic input.~~
- Add buttons.
- Add menus.
- ~~Make inputs mappable.~~
- Saving and loading.
## Physics
- ~~Add gravity, accelaration, velocity, etc.~~
- ~~Add colliders.~~
## Audio
- Add music / sound effects.
## Gameplay
- ~~Responsive but natural movement.~~
- ~~Different modes of movement: running, crouch-walking, sliding, climbing, etc.~~
- ~~Movement that is just plainly fun.~~
- Some basic puzzle components like doors and (in-world) buttons and whatnot.
- I'm still debating whether I want to amalgamate two game ideas I've had into this one project: it could be interesting to fold a constructed language into this in a neat way
but I'll have to think more about this before going through with it.
